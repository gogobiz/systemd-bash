This file is logger.def, from which is created logger.c.
It implements the builtin "logger" in Bash.

Copyright (C) 1987-2009 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Bash is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Bash.  If not, see <http://www.gnu.org/licenses/>.

$PRODUCES logger.c
#include <config.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include <stdio.h>
#define SYSLOG_NAMES
#include <syslog.h>

#include "../bashansi.h"
#include "../bashintl.h"

#include "../shell.h"
#include "../flags.h"
#include "common.h"
#include "bashgetopt.h"

#if defined (READLINE)
#  include "../input.h"
#  include "../bashline.h"
#  include <readline/readline.h>
#endif

#if defined (HISTORY)
#  include "../bashhist.h"
#endif

$BUILTIN logger
$FUNCTION logger_builtin
$DEPENDS_ON V9_ECHO
$SHORT_DOC logger [-i] [-t syslogid ] [ -p priority ] [ -e custom variables [ ... ] ] log message 
Send a message to the systemd journal

Options:
  -i  Set the syslog process id
  -t  Name the syslog identifier string
  -p  Set the log entry priority (emerg, alert, crit, err, warn, notice, info, debug)
  -e  Send a KEY=value pair along with the message to the journal

Exit Status:
Returns success unless a write error occurs.
$END

#include <systemd/sd-journal.h>

static int decode(char *name, CODE *codetab)
{
  register CODE *c;

  if (isdigit(*name))
    return (atoi(name));

  for (c = codetab; c->c_name; c++)
    if (!strcasecmp(name, c->c_name))
      return (c->c_val);

  return -1;
}

static int pencode(char *s)
{
  char *save;
  int fac, lev;

  for (save = s; *s && *s != '.'; ++s);
  if (*s) {
    *s = '\0';
    fac = decode(save, facilitynames);
    if (fac < 0)
      errx(EXIT_FAILURE, _("unknown facility name: %s."), save);
    *s++ = '.';
  }
  else {
    fac = LOG_USER;
    s = save;
  }
  lev = decode(s, prioritynames);
  if (lev < 0)
    errx(EXIT_FAILURE, _("unknown priority name: %s."), save);
  return ((lev & LOG_PRIMASK) | (fac & LOG_FACMASK));
}


int
logger_builtin (list)
     WORD_LIST *list;
{
  int c, r, opt;
  char def_pri[] = "user.notice";
  char *priority = &def_pri[0];
  char *tag = getlogin();
  int include_pid = 0;
  char *logndx, *logbuf;
  char *temp = NULL;
  WORD_LIST *input = list;
  struct iovec *iov;
  int          icnt=0;
  size_t tot = 0;

  while(input && input->word && input->word->word) {
    tot += strlen(input->word->word) + 1;
    icnt++;
    input = input->next;
  }
  icnt += 10;
  tot += 2048;
  iov = (struct iovec *)calloc(icnt,sizeof(struct iovec));

  input = list;
  icnt = 0;

  logbuf = (char *)calloc(tot,sizeof(char));
  if(logbuf==NULL) return(EX_MISCERROR);
  logndx = logbuf;

  reset_internal_getopt();
  while ((opt = internal_getopt (list, "it:p:e:")) != -1) {
    switch (opt) {
      case 'e':
        iov[icnt].iov_base=logndx;
        logndx += snprintf(logndx,  tot-strlen(logbuf), "%s", list_optarg);
        iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
        icnt++;
        input=input->next;
        input=input->next;
        break;
      case 'i':
        include_pid = 1;
        input=input->next;
        break;
      case 't':
        tag = list_optarg;
        input=input->next;
        input=input->next;
        break;
      case 'p':
        priority = list_optarg;
        input=input->next;
        input=input->next;
        break;
      default:
        free(iov);
        free(logbuf);
        builtin_usage();
        return(EX_USAGE);
    }
  }

  if(input && input->word && 0==strncmp(input->word->word,"--",2))
    input=input->next;


  terminate_immediately++;

  
  /* PRIORITY */
  
  int pri = pencode(priority);
  iov[icnt].iov_base=logndx;
  logndx += snprintf(logndx,  tot-strlen(logbuf), "PRIORITY=%d", LOG_PRI(pri));
  iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
  icnt++;
  iov[icnt].iov_base=logndx;
  logndx += snprintf(logndx,  tot-strlen(logbuf), "SYSLOG_FACILITY=%d", LOG_FAC(pri));
  iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
  icnt++;

  /* IDENTIFIER */
  if(tag) {
    iov[icnt].iov_base=logndx;
    logndx += snprintf(logndx,  tot-strlen(logbuf), "SYSLOG_IDENTIFIER=%s", tag);
    iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
    icnt++;
  }

  /* PID */
  if(include_pid) {
    iov[icnt].iov_base=logndx;
    logndx += snprintf(logndx,  tot-strlen(logbuf), "SYSLOG_PID=%u", getpid());
    iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
    icnt++;
  }

  /* MESSAGE */
  iov[icnt].iov_base=logndx;
  logndx += snprintf(logndx,  tot-strlen(logbuf), "MESSAGE=");
  if (input)
  {
    while (input)
    {
      temp = input->word->word;
      if (temp)
      {
        logndx += snprintf(logndx,  tot-strlen(logbuf), "%s", temp);
        if(input->next) {
          logndx += snprintf(logndx,  tot-strlen(logbuf), " ", temp);
        }
      }
      input = input->next;
    }
  }
  else {
    logndx += fread( logndx, sizeof(char), tot-strlen(logbuf), stdin);
  }
  
  iov[icnt].iov_len=logndx-(char*)iov[icnt].iov_base;
  icnt++;
  {
    SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
    ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
    char *funcname_s=NULL, *source_s=NULL, *lineno_s=NULL;
  
    GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
    GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
    GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
  
    if (bash_lineno_a && ! array_empty (bash_lineno_a)) {
      lineno_s = array_reference (bash_lineno_a, 0);
      iov[icnt].iov_base=logndx;
      logndx += snprintf(logndx,  tot-strlen(logbuf), "BASH_LINENO=%s", lineno_s);
      iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
      icnt++;
    }
    if (bash_source_a && ! array_empty (bash_source_a)) {
      source_s = array_reference (bash_source_a, 1);
      iov[icnt].iov_base=logndx;
      logndx += snprintf(logndx,  tot-strlen(logbuf), "BASH_SOURCE=%s", source_s);
      iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
      icnt++;
    }
    if (funcname_a && ! array_empty (funcname_a)) {
      funcname_s = array_reference (funcname_a, 1);
      iov[icnt].iov_base=logndx;
      logndx += snprintf(logndx,  tot-strlen(logbuf), "BASH_FUNCTION=%s", funcname_s);
      iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
      icnt++;
    }
  } 

  {
    char *trace=NULL;
    trace=get_string_value("TRACE");
    if(trace) {
      iov[icnt].iov_base=logndx;
      logndx += snprintf(logndx,  tot-strlen(logbuf), "TRACE=%s", trace);
      iov[icnt].iov_len = logndx-(char*)iov[icnt].iov_base;
      icnt++;
    }
  }
  sd_journal_sendv(iov, icnt);
  free(iov);
  free(logbuf);

  terminate_immediately--;
  return (sh_chkwrite (EXECUTION_SUCCESS));
}
